#!/usr/bin/env perl
BEGIN {
    $|=1;
    use FindBin qw($RealBin);
    
    # Use $RealBin which automatically resolves symlinks
    # This ensures lib path is correct even when clio is invoked via symlink
    use lib "$RealBin/lib";
}

use strict;
use warnings;
use File::Spec;
use File::Basename;
use File::Path qw(make_path);
use JSON::PP;
use CLIO::UI::Chat;
use CLIO::Util::PathResolver;
use CLIO::Core::Logger qw(should_log);

# Parse early CLI options BEFORE module init (--config and --no-color)
my $config_dir_override;
my $no_color = 0;
for (my $i = 0; $i < @ARGV; $i++) {
    if ($ARGV[$i] eq '--config' && defined $ARGV[$i+1]) {
        $config_dir_override = $ARGV[$i+1];
    }
    if ($ARGV[$i] eq '--no-color') {
        $no_color = 1;
        $ENV{NO_COLOR} = 1;  # Standard env var for no-color output
    }
}

# Initialize path resolver early (with config override if provided)
if ($config_dir_override) {
    CLIO::Util::PathResolver::init(base_dir => $config_dir_override);
} else {
    CLIO::Util::PathResolver::init();
}

# Check for --help flag
if (grep { $_ eq '--help' || $_ eq '-h' } @ARGV) {
    print <<'HELP';
CLIO - Command Line Intelligent Operator
AI-Powered Development Assistant

USAGE:
    clio [OPTIONS]

OPTIONS:
    --new              Start a new session
    --resume [ID]      Resume a session (most recent if no ID provided)
    --debug            Enable debug output
    --dir <path>       Set working directory for session
    --input <text>     Process input and exit
    --exit             Exit after processing (with --input)
    --model <name>     Use specific model (temporary, not persisted)
    --sandbox          Restrict file access to project directory only
    --config <path>    Use custom config directory (for isolated testing)
    --no-color         Disable ANSI color output (for CI/workflows)
    --no-custom-instructions  Skip .clio/instructions.md
    --no-ltm           Skip long-term memory pattern injection
    --incognito        Skip both custom instructions AND LTM (fresh audit mode)
    --help, -h         Display this help message

EXAMPLES:
    clio --new                    # Start new session
    clio --resume                 # Resume most recent session
    clio --resume <session_id>    # Resume specific session
    clio --debug --new            # Start with debug logging
    clio --dir /path/to/project   # Start in specific directory
    clio --model gpt-4.1 --new    # Start with specific model
    clio --incognito --new        # Fresh audit without project knowledge
    clio --config /tmp/clio-test  # Use isolated config for testing
    clio --no-color --input "hi"  # Non-interactive without color

SESSIONS:
    Sessions are stored in: .clio/sessions/
    Each session has a unique UUID identifier
    Use /switch command to list and switch between sessions

SLASH COMMANDS:
    Type /help in the application for available commands

ENVIRONMENT:
    CLIO_HOME          Override CLIO base directory
    NO_COLOR           Disable color output (same as --no-color)

HELP
    exit 0;
}

# Set debug level from --debug flag
# CRITICAL: Set in BEGIN block so should_log() works when modules load
BEGIN {
    if (grep { $_ eq '--debug' } @ARGV) {
        $ENV{CLIO_LOG_LEVEL} = 'DEBUG';
    }
}
my $debug = grep { $_ eq '--debug' } @ARGV ? 1 : 0;

my $input = '';
my $session_id = '';
my $mode = '';
my $working_dir = '';
my $session;

# Validate and create required directories
my $base_dir = $FindBin::Bin;
my @required_dirs = (
    File::Spec->catdir($base_dir, '.clio/sessions'),
);

for my $dir (@required_dirs) {
    unless (-d $dir) {
        print STDERR "Creating directory: $dir\n" if $debug;
        make_path($dir) or die "Failed to create directory $dir: $!";
    }
}

# Load required modules
use CLIO::Core::APIManager;
use CLIO::Core::SimpleAIAgent;
use CLIO::Core::Config;
use CLIO::Session::Manager;
use CLIO::Protocols::Manager;
use CLIO::Core::CommandParser;

# Register ALL protocol handlers including enhanced protocols
CLIO::Protocols::Manager->register(name => 'FILE_OP', handler => 'CLIO::Protocols::FileOp');
CLIO::Protocols::Manager->register(name => 'GIT', handler => 'CLIO::Protocols::Git');
CLIO::Protocols::Manager->register(name => 'RAG', handler => 'CLIO::Protocols::RAG');
CLIO::Protocols::Manager->register(name => 'MEMORY', handler => 'CLIO::Protocols::Memory');
CLIO::Protocols::Manager->register(name => 'RECALL', handler => 'CLIO::Protocols::Recall');
CLIO::Protocols::Manager->register(name => 'SEARCH', handler => 'CLIO::Protocols::Search');
CLIO::Protocols::Manager->register(name => 'URL_FETCH', handler => 'CLIO::Protocols::UrlFetch');
CLIO::Protocols::Manager->register(name => 'WEB_SEARCH', handler => 'CLIO::Protocols::WebSearch');
CLIO::Protocols::Manager->register(name => 'CODE_ANALYSIS', handler => 'CLIO::Protocols::CodeAnalysis');
CLIO::Protocols::Manager->register(name => 'VALIDATE', handler => 'CLIO::Protocols::Validate');
CLIO::Protocols::Manager->register(name => 'PATTERN', handler => 'CLIO::Protocols::Pattern');
CLIO::Protocols::Manager->register(name => 'REFACTOR', handler => 'CLIO::Protocols::Refactor');
CLIO::Protocols::Manager->register(name => 'SECURITY', handler => 'CLIO::Protocols::Security');
CLIO::Protocols::Manager->register(name => 'AUDIT', handler => 'CLIO::Protocols::Audit');

# Initialize configuration system
my $config = CLIO::Core::Config->new(debug => $debug);

# Parse command line arguments
my $should_exit = 0;
my $skip_custom = 0;
my $skip_ltm = 0;
my $sandbox_mode = 0;  # Sandbox mode - restrict file access to project directory
my $model_override = undef;  # Temporary model override from --model flag
for (my $i = 0; $i < @ARGV; $i++) {
    if ($ARGV[$i] eq '--input' && defined $ARGV[$i+1]) {
        $input = $ARGV[$i+1];
    }
    if ($ARGV[$i] eq '--dir' && defined $ARGV[$i+1]) {
        $working_dir = $ARGV[$i+1];
    }
    if ($ARGV[$i] eq '--new') {
        $mode = 'new';
    }
    if ($ARGV[$i] eq '--resume') {
        $mode = 'resume';
        # If next arg is not another flag, treat as session id
        if (defined $ARGV[$i+1] && $ARGV[$i+1] !~ /^--/) {
            $session_id = $ARGV[$i+1];
        }
    }
    if ($ARGV[$i] eq '--exit') {
        $should_exit = 1;
    }
    if ($ARGV[$i] eq '--no-custom-instructions') {
        $skip_custom = 1;
    }
    if ($ARGV[$i] eq '--no-ltm') {
        $skip_ltm = 1;
    }
    if ($ARGV[$i] eq '--incognito') {
        # Incognito mode enables both skip flags
        $skip_custom = 1;
        $skip_ltm = 1;
    }
    if ($ARGV[$i] eq '--sandbox') {
        $sandbox_mode = 1;
    }
    if ($ARGV[$i] eq '--model' && defined $ARGV[$i+1]) {
        $model_override = $ARGV[$i+1];
    }
}

# If no --input flag was provided but STDIN is piped (not a TTY), read from STDIN
if (!$input && !-t STDIN) {
    my $piped_input = '';
    while (my $line = <STDIN>) {
        $piped_input .= $line;
    }
    $input = $piped_input;
    chomp $input;
    print STDERR "[DEBUG] Read " . length($input) . " bytes from piped STDIN\n" if $debug;
}

# Default to 'new' mode if not specified
if (!$mode) {
    print STDERR "[TRACE] No mode specified, defaulting to 'new'\n" if $debug;
    $mode = 'new';
}
print STDERR "[TRACE] Mode before session creation: $mode\n" if $debug;

# Set sandbox mode in config (runtime only, not persisted)
if ($sandbox_mode) {
    $config->set('sandbox', 1, 0);  # 0 = don't mark as user-set (not persisted)
    print STDERR "[INFO] Sandbox mode enabled - file access restricted to project directory\n";
}

# Create or load session
if ($mode eq 'new') {
    my $eval_err;
    eval {
        $session = CLIO::Session::Manager->create(
            debug => $debug,
            working_directory => $working_dir
        );
    };
    $eval_err = $@;
    if ($debug) {
        require Data::Dumper;
        print STDERR "[DEBUG] Session object after create: " . Data::Dumper::Dumper($session);
        print STDERR "[DEBUG] session_id after create: ", (defined $session ? $session->{session_id} // '[undef]' : '[no session]'), "\n";
        print STDERR "[TRACE][EVAL] Error during create: $eval_err\n" if $eval_err;
    }
    $session_id = $session->{session_id} // ($session->{state} ? $session->{state}->{session_id} : undef) if $session;
    print "[DEBUG] Created new session: $session_id\n" if $debug && $session_id;
    print STDERR "[TRACE] After new: session defined? ", (defined $session ? 'yes' : 'no'), "\n" if $debug;
    
    # Add system prompt to session history ONCE at session start (not on every request!)
    if ($session) {
        use CLIO::Core::PromptManager;
        my $pm = CLIO::Core::PromptManager->new(debug => $debug, skip_custom => $skip_custom);
        my $system_prompt = $pm->get_system_prompt($session);  # Pass session for LTM injection
        $session->add_message('system', $system_prompt);
        print STDERR "[DEBUG] Added system prompt to session history (" . length($system_prompt) . " chars)\n" if $debug;
    }
} elsif ($mode eq 'resume') {
    my $eval_err;
    if ($session_id) {
        eval {
            $session = CLIO::Session::Manager->load($session_id, debug => $debug);
        };
        $eval_err = $@;
        print STDERR "[TRACE][EVAL] Error during load by id: $eval_err\n" if $debug;
        print STDERR "[TRACE] After load by id: session defined? ", (defined $session ? 'yes' : 'no'), "\n" if $debug;
        if (!$session) {
            print "[ERROR] Failed to load session $session_id\n";
        }
    } else {
        # Resume most recent session if no ID provided
        # Sort by file modification time (mtime), not creation timestamp, to ensure most recently used session is loaded
        # When a session is resumed and exited gracefully, its mtime is updated, so mtime tracks actual usage
        my $sessions_dir = CLIO::Util::PathResolver::get_sessions_dir();
        opendir(my $dh, $sessions_dir) or die "Cannot open sessions dir: $!";
        my @json_files = grep { /\.json$/ } readdir($dh);
        closedir($dh);
        
        if (@json_files) {
            # Load all sessions and sort by file modification time (mtime)
            my @sessions_with_mtime = ();
            foreach my $json_file (@json_files) {
                my $sid = $json_file;
                $sid =~ s/\.json$//;
                my $file_path = "$sessions_dir/$json_file";
                # Use file stat to get mtime (more reliable than stored timestamp)
                my @stat = stat($file_path);
                my $mtime = $stat[9] // 0;  # 9 is the mtime field
                push @sessions_with_mtime, { id => $sid, mtime => $mtime, path => $file_path };
            }
            
            # Sort by modification time in descending order (most recent first)
            @sessions_with_mtime = sort { $b->{mtime} <=> $a->{mtime} } @sessions_with_mtime;
            
            if (@sessions_with_mtime) {
                $session_id = $sessions_with_mtime[0]->{id};
                eval {
                    $session = CLIO::Session::Manager->load($session_id, debug => $debug);
                };
                $eval_err = $@;
                print STDERR "[TRACE][EVAL] Error during load most recent: $eval_err\n" if $debug;
                print STDERR "[TRACE] After load most recent: session defined? ", (defined $session ? 'yes' : 'no'), "\n" if $debug;
                if (!$session) {
                    print "[ERROR] Failed to load most recent session $session_id\n";
                }
            }
        }
    }
    # Always fallback to new session if loading failed
    if (!$session) {
        eval {
            $session = CLIO::Session::Manager->create(debug => $debug);
        };
        $eval_err = $@;
        $session_id = $session->{session_id} // ($session->{state} ? $session->{state}->{session_id} : undef) if $session;
        print "[DEBUG] Created new session (fallback): $session_id\n" if $debug && $session_id;
        print STDERR "[TRACE][EVAL] Error during fallback create: $eval_err\n" if $debug;
        print STDERR "[TRACE] After fallback create: session defined? ", (defined $session ? 'yes' : 'no'), "\n" if $debug;
        
        # Add system prompt to fallback session (same as regular new session)
        if ($session) {
            use CLIO::Core::PromptManager;
            my $pm = CLIO::Core::PromptManager->new(debug => $debug, skip_custom => $skip_custom);
            my $system_prompt = $pm->get_system_prompt($session);  # Pass session for LTM injection
            $session->add_message('system', $system_prompt);
            print STDERR "[DEBUG] Added system prompt to fallback session (" . length($system_prompt) . " chars)\n" if $debug;
        }
    } else {
        $session_id = $session->{session_id} // ($session->{state} ? $session->{state}->{session_id} : undef);
        print "[DEBUG] Resumed session: $session_id\n" if $debug;
        
        # CRITICAL: Apply session's saved model to config
        # This ensures resumed sessions use the model they were using, not the global default
        # Check both api_config{model} (from /api set) and selected_model (from API usage)
        my $session_state = $session->state();
        if ($session_state) {
            # Priority: api_config{model} (explicit user setting) > selected_model (from API)
            my $session_model = $session_state->{api_config}{model}
                             // $session_state->{selected_model};
            
            if ($session_model) {
                $config->set('model', $session_model, 0);  # 0 = don't mark as user-set
                print STDERR "[DEBUG] Applied session model to config: $session_model\n" if $debug;
            }
        }
    }
}

print STDERR "[TRACE] Before session check: session defined? ", (defined $session ? 'yes' : 'no'), "\n" if $debug;
if (!$session) {
    print "[ERROR] Could not create or load a session. Exiting.\n";
    exit 2;
}
print "[SESSION] Using session: $session_id\n" if $debug;

# Check for broker coordination (sub-agent mode)
my $broker_client;
my $broker_session = $ENV{CLIO_BROKER_SESSION} || '';
my $broker_agent_id = $ENV{CLIO_BROKER_AGENT_ID} || '';

print STDERR "[TRACE][BROKER] Checking env vars: SESSION=$broker_session, AGENT=$broker_agent_id\n" if should_log('TRACE');

if ($broker_session && $broker_agent_id) {
    print STDERR "[INFO] Detected sub-agent mode (broker env vars present)\n" if should_log('INFO');
    print STDERR "[INFO] Broker session: $broker_session\n" if should_log('INFO');
    print STDERR "[INFO] Agent ID: $broker_agent_id\n" if should_log('INFO');
    
    eval {
        require CLIO::Coordination::Client;
        $broker_client = CLIO::Coordination::Client->new(
            session_id => $broker_session,
            agent_id => $broker_agent_id,
            task => $input || "Unnamed task",
            debug => $debug,
        );
        print STDERR "[INFO] Connected to broker successfully\n" if should_log('INFO');
    };
    if ($@) {
        print STDERR "[WARN] Could not connect to broker: $@\n" if should_log('WARN');
        print STDERR "[WARN] Continuing without coordination\n" if should_log('WARN');
    }
} else {
    print STDERR "[TRACE][BROKER] No broker env vars, running standalone\n" if should_log('TRACE');
}

# Migrate model names to provider/model format (backward compatibility)
# Existing users may have "gpt-4.1" instead of "github_copilot/gpt-4.1"
{
    my $current_model = $config->get('model') || '';
    my $current_provider = $config->get('provider') || '';
    
    if ($current_model && $current_provider) {
        require CLIO::Providers;
        # Check if model already has a provider prefix
        my $has_prefix = 0;
        if ($current_model =~ m{^([a-z][a-z0-9_.-]*)/}i) {
            $has_prefix = CLIO::Providers::provider_exists($1);
        }
        
        unless ($has_prefix) {
            my $full_model = "$current_provider/$current_model";
            $config->set('model', $full_model, 0);
            print STDERR "[DEBUG] Migrated model to provider/model format: $full_model\n" if $debug;
        }
    }
}

# Apply --model override if specified (temporary, not persisted to config file)
if ($model_override) {
    # Auto-prepend current provider if no provider prefix
    require CLIO::Providers;
    if ($model_override !~ m{^([a-z][a-z0-9_.-]*)/}i || 
        !CLIO::Providers::provider_exists($1)) {
        my $provider = $config->get('provider') || '';
        if ($provider) {
            $model_override = "$provider/$model_override";
        }
    }
    $config->set('model', $model_override, 0);  # 0 = don't mark as user-set (not persisted)
    print STDERR "[DEBUG] Applied --model override: $model_override\n" if $debug;
    print "[INFO] Using temporary model: $model_override\n";
}

# Initialize API manager and AI agent
my $api = CLIO::Core::APIManager->new(
    debug => $debug,
    session => $session->state(),
    config => $config,
    broker_client => $broker_client,  # Pass broker client for API rate limiting coordination
);
my $ai_agent = CLIO::Core::SimpleAIAgent->new(
    debug => $debug,
    session => $session,
    api => $api,
    skip_custom => $skip_custom,
    skip_ltm => $skip_ltm,
    broker_client => $broker_client,  # Pass broker client for coordination
    non_interactive => $input ? 1 : 0,  # Non-interactive mode when --input is used
);

if ($debug) {
    my $cfg = $config->get_all();
    print "[DEBUG] API base: " . ($cfg->{api_base} || '(not set)') . "\n";
    print "[DEBUG] Model: " . ($cfg->{model} || '(not set)') . "\n";
    if ($skip_custom || $skip_ltm) {
        print "[DEBUG] Incognito mode: skip_custom=$skip_custom, skip_ltm=$skip_ltm\n";
    }
}

# Handle command line input if provided
if ($input) {
    # Create UI for tool output formatting even in --input mode
    require CLIO::UI::Chat;
    my $cli_ui = CLIO::UI::Chat->new(
        session => $session,
        ai_agent => $ai_agent,
        config => $config,
        debug => $debug,
        no_color => $no_color
    );
    $ai_agent->set_ui($cli_ui) if $ai_agent;
    
    # Handle protocol commands first (unchanged)
    if ($input =~ /^\[MEMORY:/) {
        my $resp = CLIO::Protocols::Manager->handle($input, $session);
        $session->save();
        print "[DEBUG] Session saved to $session->{state}->{file}\n" if $debug;
        require Data::Dumper;
        print Data::Dumper::Dumper($resp);
        exit 0;
    }
    
    # Create command parser for stacked commands
    my $parser = CLIO::Core::CommandParser->new(debug => $debug);
    my $commands = $parser->parse_commands($input);
    
    if ($debug) {
        print "[DEBUG] Processing " . scalar(@$commands) . " commands\n";
    }
    
    # Process each command in sequence
    for my $i (0 .. $#{$commands}) {
        my $command = $commands->[$i];
        
        if ($debug) {
            print "[DEBUG] Processing command " . ($i + 1) . ": '$command'\n";
        }
        
        # Handle slash commands locally (don't send to AI)
        if ($command =~ /^\//) {
            print STDERR "[DEBUG] Detected slash command: $command\n" if $debug;
            
            # Extract command and args
            my $cmd = $command;
            $cmd =~ s/^\///;  # Remove leading slash
            my ($cmd_name, @cmd_args) = split /\s+/, $cmd;
            $cmd_name = lc($cmd_name);
            
            # Handle common slash commands
            if ($cmd_name eq 'help' || $cmd_name eq 'h' || $cmd_name eq '?') {
                print "[SYSTEM] CLIO Slash Commands:\n";
                print "  /help, /h, /?              Display help\n";
                print "  /exit, /quit, /q           Exit CLIO\n";
                print "  /clear, /cls               Clear screen\n";
                print "  /reset                     Reset terminal state\n";
                print "  /debug                     Toggle debug mode\n";
                print "  /session                   Show session ID\n";
                print "  /config                    Show configuration\n";
                print "  /api                       Show API status\n";
                print "  /subagent, /agent          Multi-agent commands\n";
                print "\n";
                print "For full command list, use interactive mode (./clio)\n";
                next;  # Skip to next command
            }
            elsif ($cmd_name eq 'exit' || $cmd_name eq 'quit' || $cmd_name eq 'q') {
                print "[SYSTEM] Exiting...\n";
                last;  # Exit command loop
            }
            elsif ($cmd_name eq 'debug') {
                $debug = !$debug;
                $ENV{CLIO_LOG_LEVEL} = $debug ? 'DEBUG' : 'INFO';
                print "[SYSTEM] Debug mode: " . ($debug ? "ON" : "OFF") . "\n";
                next;
            }
            elsif ($cmd_name eq 'session') {
                print "[SYSTEM] Current session: " . ($session->{session_id} || 'unknown') . "\n";
                next;
            }
            elsif ($cmd_name eq 'subagent' || $cmd_name eq 'agent') {
                # Handle subagent commands
                require CLIO::UI::Commands::SubAgent;
                my $subagent_cmd = CLIO::UI::Commands::SubAgent->new(chat => $cli_ui);
                my $subcommand = shift @cmd_args || 'help';
                my $args = join(' ', @cmd_args);
                my $result = $subagent_cmd->handle($subcommand, $args);
                print "$result\n";
                next;
            }
            elsif ($cmd_name eq 'reset') {
                # Terminal reset - restore terminal to known-good state
                # Use full reset since user explicitly requested it
                require CLIO::Compat::Terminal;
                CLIO::Compat::Terminal::reset_terminal_full();
                print "[SYSTEM] Terminal reset complete\n";
                next;
            }
            else {
                print "[SYSTEM] Unknown slash command: $command\n";
                print "[SYSTEM] Type /help for available commands\n";
                print "[SYSTEM] Note: Some commands only work in interactive mode\n";
                next;
            }
        }
        
        # Check if this is a recall query
        if ($parser->is_recall_query($command)) {
            # Handle recall query directly from memory
            my $stm = $session->{stm} // $session->{state}->{stm};
            my $recall_result = $parser->extract_recall_context($command, $stm);
            
            if ($recall_result && $recall_result->{content}) {
                my $response = "You said: \"$recall_result->{content}\"";
                print "[RESPONSE] $response\n";
                
                # Add to session history
                $session->add_message('user', $command);
                $session->add_message('assistant', $response);
            } else {
                my $response = "I couldn't find what you're referring to in our conversation.";
                print "[RESPONSE] $response\n";
                
                # Add to session history
                $session->add_message('user', $command);
                $session->add_message('assistant', $response);
            }
        } else {
            # Regular command - use enhanced AI agent
            my $result = $ai_agent->process_user_request($command, {
                current_file => $session->{state}->{current_file},
                working_directory => $session->{state}->{working_directory},
                conversation_history => $session->{state}->{history}
            });
            
            if ($result->{success}) {
                my $response = $result->{final_response};
                # Remove [conversation]...[/conversation] tags if present
                $response =~ s/^\[conversation\]//;
                $response =~ s/\[\/conversation\]$//;
                $response =~ s/^\s+|\s+$//g;
                
                $session->add_message('assistant', $response);
                
                # Render markdown for --input mode
                use CLIO::UI::Markdown;
                use CLIO::UI::ANSI;
                my $md = CLIO::UI::Markdown->new(debug => $debug);
                my $ansi = CLIO::UI::ANSI->new(enabled => !$no_color, debug => $debug);
                
                # Render markdown (adds @-codes), then parse @-codes to ANSI
                my $rendered_response = $md->render($response);
                $rendered_response = $ansi->parse($rendered_response);
                
                # Set UTF-8 output and print (no encode_utf8 needed with binmode)
                binmode(STDOUT, ':encoding(UTF-8)');
                print "[RESPONSE] $rendered_response\n";
                
                # Show protocol usage if debug mode
                if ($debug && @{$result->{protocols_used}}) {
                    print "[DEBUG] Protocols used: " . join(", ", @{$result->{protocols_used}}) . "\n";
                }
            } else {
                my $error_msg = "[ERROR] " . join("; ", @{$result->{errors}});
                $session->add_message('system', $error_msg);
                print "$error_msg\n";
            }
        }
    }
    
    # Save session after processing all commands
    $session->save();
    
    # Exit if --exit flag was provided
    if ($should_exit) {
        exit 0;
    }
}

# If --exit is present, exit immediately after session setup (unless --input was handled above)
if ($should_exit && !$input) {
    exit 0;
}

# Otherwise, launch the clean chat UI
my $ui = CLIO::UI::Chat->new(
    session => $session,
    ai_agent => $ai_agent,
    config => $config,
    debug => $debug,
    no_color => $no_color
);

# Set UI on ai_agent so orchestrator can access it for collaboration
$ai_agent->set_ui($ui) if $ai_agent;

# Display repair notification if session history was cleaned up on resume
# This provides user-friendly feedback instead of raw debug warnings
if ($session && $session->can('state') && $session->state()) {
    my $state = $session->state();
    if ($state->can('repair_notification') && $state->repair_notification()) {
        my $message = $state->repair_notification();
        # Display as styled system message
        $ui->display_system_message($message);
    }
}

# Register signal handlers to save session on Ctrl+C or SIGTERM
# This ensures context is preserved when user interrupts the program
{
    my $session_ref = \$session;  # Capture in closure
    my $ui_ref = \$ui;            # Capture UI for styled output
    my $cleanup_done = 0;
    
    my $cleanup_handler = sub {
        my ($sig) = @_;
        return if $cleanup_done;  # Prevent multiple executions
        $cleanup_done = 1;
        
        # CRITICAL: Restore terminal mode FIRST before any output
        # Otherwise output may be corrupted or doubled
        eval {
            require CLIO::Compat::Terminal;
            CLIO::Compat::Terminal::ReadMode('restore');
        };
        
        # CRITICAL: Force output to appear immediately
        local $| = 1;
        
        # Print newline to clear any partial input line
        print "\n";
        
        # Use styled output if UI is available, otherwise plain text
        if ($$ui_ref && $$ui_ref->can('display_system_message')) {
            # Buffer system messages for grouped display
            my @messages = ("Saving session...");
            
            if ($$session_ref) {
                eval {
                    $$session_ref->save();
                    push @messages, "Session saved.";
                };
                if ($@) {
                    push @messages, "ERROR: Failed to save session: $@";
                }
            } else {
                push @messages, "WARN: No session to save";
            }
            
            # Display all messages as a single grouped output
            $$ui_ref->display_system_messages(\@messages);
        } else {
            print "SYSTEM: Saving session...\n";
            
            if ($$session_ref) {
                eval {
                    $$session_ref->save();
                    print "SYSTEM: Session saved.\n";
                };
                if ($@) {
                    print STDERR "[ERROR] Failed to save session: $@\n";
                }
            } else {
                print STDERR "[WARN] No session to save (session object is undefined)\n";
            }
        }
        
        # Force STDERR flush
        STDERR->flush();
        STDOUT->flush();
        
        # Exit with code 0 for clean user-initiated exit
        exit 0;
    };
    
    $SIG{INT}  = $cleanup_handler;  # Ctrl+C
    $SIG{TERM} = $cleanup_handler;  # SIGTERM
}

# END block: Final safety net to restore terminal on ANY exit
# This catches unhandled exceptions, die calls, and other unexpected exits
END {
    eval {
        require CLIO::Compat::Terminal;
        CLIO::Compat::Terminal::ReadMode('restore');
    };
    # Silently ignore errors - we're exiting anyway
}

$ui->run();

# CRITICAL: Restore terminal mode before final session save
# This ensures terminal is in normal mode even if run() exited abnormally
eval {
    require CLIO::Compat::Terminal;
    CLIO::Compat::Terminal::ReadMode('restore');
};

# Save session after interactive mode completes
# This ensures all conversation history, including errors, is persisted
# Group all exit messages together for consistency
my @exit_messages = ("Saving session");
$session->save();
push @exit_messages, "Goodbye!";

if ($ui && $ui->can('display_system_messages')) {
    $ui->display_system_messages(\@exit_messages);
} else {
    for my $msg (@exit_messages) {
        print "SYSTEM: $msg\n";
    }
}
print "[DEBUG] Session saved after interactive mode\n" if $debug;

exit 0;
